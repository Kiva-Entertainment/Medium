using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class MoveRange {

	// Offsets in each of 4 cardinal directions each with length of 1
	static readonly Loc[] CARDINAL_OFFSETS = { new Loc (1, 0),
												new Loc (-1, 0),
												new Loc (0, 1),
												new Loc (0, -1) };

	/// <summary>
	/// Determine what moves given unit can make
	/// </summary>
	/// <param name="unit">The unit being considered.</param>
	public static Move[] determine (Unit unit) {
		List<Move> result = new List<Move> ();

		// First move used for generating next ring of moves
		Move start = new Move (unit,
								start: unit.loc,
								end: unit.loc,
								mvConsumed: 0);

		// The previously determined list of moves
		// After each iteration of the for loop, this list is set to the results that time
		// The next ring is generated based on the previous ring
		List<Move> fromRing = new List<Move> ();
		fromRing.Add (start);

		// Determine all moves 1 space away, then 2, etc.
		for ( int dMv = 1; dMv < unit.mvCur + 1; dMv++ ) {

			// New ring generated by spreading from last ring
			List<Move> newRing = spread (fromRing);

			// Reset fromRing, repopulate in loop below
			fromRing = new List<Move>();

			// Add each new move if it it hasn't been considered before
			foreach (Move newMove in newRing) {

				// Ensure no doubles get added
				if (spaceUnique(newMove, result)) {
					result.Add(newMove);
					fromRing.Add (newMove);
				}
			}
		}

		return result.ToArray ();
	}

	/// <summary>
	/// Spread from given from ring by 1 space and return list of all resulting moves.
	/// May return multiple entries for given space.
	/// </summary>
	/// <param name="fromRing">List of moves that we spread from.</param>
	static List<Move> spread (List<Move> fromRing)
	{
		List<Move> result = new List<Move> ();

		// Consider each space 1 space away (In any direction) from each space in fromRing
		foreach (Move prevMove in fromRing) {
			foreach (Loc offset in CARDINAL_OFFSETS) {

				Move potMove = new Move (actor: prevMove.actor,
				                         start: prevMove.actor.loc,
				                         end: prevMove.end.plus (offset),
				                         mvConsumed: prevMove.mvConsumed + 1);

				if ( isValid(potMove, lastLoc: prevMove.end) )
					result.Add (potMove);
			}
		}

		return result;
	}

	/// <summary>
	/// Check if given move is valid/possible.
	/// </summary>
	static bool isValid(Move move, Loc lastLoc) {
		// Check if space is in bounds
		if ( !World.current.isInBounds(move.end) )
			return false;

		// Check that space not hole
		if ( World.current.isHole(move.end) )
			return false;

		// Check that is not occupied already
		if ( World.current.getUnit(move.end) != null )
			return false;

		// Check that height is not too great
		float dHeight = Mathf.Abs (World.current.getHeight (move.end)
									- World.current.getHeight (lastLoc));
		if ( dHeight > move.actor.jump )
			return false;

		// If none of above tests failed, is valid space to move to
		return true;
	}

	/// <summary>
	/// Check that given move isn't to a space that already has been considered.
	/// </summary>
	static bool spaceUnique (Move newMove, List<Move> result)
	{
		foreach (Move recordedMove in result)
			if (newMove.end.Equals (recordedMove.end))
				return false;
		
		return true;
	}
}
