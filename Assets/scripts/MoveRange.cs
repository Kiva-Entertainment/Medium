using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class MoveRange {

	// Offsets in each of 4 cardinal directions each with length of 1
	static readonly Loc[] CARDINAL_OFFSETS = { new Loc (1, 0),
												new Loc (-1, 0),
												new Loc (0, 1),
												new Loc (0, -1) };

	/// <summary>
	/// Determine what moves given unit can make
	/// </summary>
	/// <param name="unit">The unit being considered.</param>
	public static Move[] determine (Unit unit) {
		List<Move> result = new List<Move> ();

		// Starting position, takes 0 mv
		Move start = new Move (unit.loc, mvConsumed: 0);

		// The previously determined list of moves
		// After each iteration of the for loop, this list is set to the results that time
		// The next ring is generated based on the previous ring
		List<Move> fromRing = new List<Move> ();
		fromRing.Add (start);

		// Determine all moves 1 space away, then 2, etc.
		for ( int dMv = 1; dMv < unit.mvCur + 1; dMv++ ) {

			// New ring generated by spreading from last ring
			List<Move> newRing = spread (fromRing, dMv, unit);

			// Reset fromRing, repopulate in loop below
			fromRing = new List<Move>();

			// Add each new move if it it hasn't been considered before
			foreach (Move newMove in newRing) {

				// Ensure no doubles get added
				if (spaceUnique(newMove, result)) {
					result.Add(newMove);
					fromRing.Add (newMove);
				}
			}
		}

		return result.ToArray ();
	}

	/// <summary>
	/// Spread from given from ring by 1 space and return list of all resulting moves.
	/// May return multiple entries for given space.
	/// </summary>
	/// <param name="fromRing">List of moves that we spread from.</param>
	/// <param name="dMv">Amount of mv this move will cost.</param>
	/// <param name="unit">The unit which is performing the move. Used to check if move is valid.</param>
	static List<Move> spread (List<Move> fromRing, int dMv, Unit unit)
	{
		List<Move> result = new List<Move> ();

		// Consider each space 1 space away (In any direction) from each space in fromRing
		foreach (Move prevMove in fromRing) {
			foreach (Loc offset in CARDINAL_OFFSETS) {

				// The space to be considered, gets added if move is valid
				Loc potLoc = prevMove.loc.plus (offset);
				if (isValid(potLoc, prevMove, unit))
					result.Add (new Move(potLoc, dMv));
			}
		}

		return result;
	}

	/// <summary>
	/// Check if move is valid.
	/// </summary>
	static bool isValid(Loc loc, Move prevMove, Unit unit) {
		// Check if space is in bounds
		if ( !World.current.isInBounds(loc) )
			return false;

		// Check that space not hole
		if ( World.current.isHole(loc) )
			return false;

		// Check that is not occupied already
		if ( World.current.getUnit(loc) != null )
			return false;

		// Check that height is not too great
		float dHeight = Mathf.Abs (World.current.getHeight (loc) - World.current.getHeight (prevMove.loc));
		if ( dHeight > unit.jump )
			return false;

		// If none of above tests failed, is valid space to move to
		return true;
	}

	/// <summary>
	/// Check that given move isn't to a space that already has been considered.
	/// </summary>
	static bool spaceUnique (Move newMove, List<Move> result)
	{
		foreach (Move recordedMove in result)
			if (newMove.loc.Equals (recordedMove.loc))
				return false;
		
		return true;
	}
}

/// <summary>
/// A movement of a unit to a given location which consumes some amount of mv based on the length
/// of the path the unit must follow to get there.
/// </summary>
public class Move {
	public readonly Loc loc;
	public readonly int mvConsumed;

	public Move (Loc loc, int mvConsumed) {
		this.loc = loc;
		this.mvConsumed = mvConsumed;
	}
}
